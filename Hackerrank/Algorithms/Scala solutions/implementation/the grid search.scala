object Solution {
    def main(args: Array[String]) {
        for (_ <- 0 until readInt) {
            var Array(r,c) = readLine.split(" ").map(_.toInt)
            val grid = Array.fill(r)(readLine)
            var Array(pRow,pColumn) = readLine.split(" ").map(_.toInt)
            val pattern = Array.fill(pRow)(readLine)

            var count = 0
            var lastIndex = 0
            for (i <- 0 until grid.length if(pRow!=count)) {
                if (count > 0) {
                    if(grid(i).contains(pattern(count))) {
                        if (lastIndex == grid(i).indexOf(pattern(count)) ||
                            grid(i-1)(grid(i).indexOf(pattern(count)))==pattern(count-1)(0)) count +=1
                        else count = 0
                    } else {
                        if(grid(i).contains(pattern(0))) {
                        count = 1
                        lastIndex = grid(i).indexOf(pattern(count))
                        }
                        else count=0
                    }
                }
                else {
                    if(grid(i).contains(pattern(count))) {
                        lastIndex = grid(i).indexOf(pattern(count))
                        count = 1
                    }
                }
            }
            println(if(count==pRow) "YES" else "NO")
        }
    }
}

//awsome solution (but doesnt actually pass all the TC that were obviously added later)
object Solution {

    def main(args: Array[String]) {
        val t = readInt()
        for (_ <- 0 until t) {
            val Array(r, c) = readLine().split(" ").map(_.toInt)
            val big = (0 until r).map(_ => readLine())
            val Array(rr, cc) = readLine().split(" ").map(_.toInt)
            val small = (0 until rr).map(_ => readLine())
            val isOk = (0 to r - rr).exists(i => {
                val j = big(i).indexOf(small(0))
                if (j < 0) {
                    false
                } else {
                    val end = j + cc
                    (1 until rr).forall(k => big(i + k).substring(j, end) == small(k))
                }
            })
            println(if (isOk) "YES" else "NO")
        }
    }
}

/*Given a 2D array of digits, try to find the location of a given 2D pattern of digits. For example, consider the following 2D matrix:

1234567890
0987654321
1111111111
1111111111
2222222222
Assume we need to look for the following 2D pattern:

876543
111111
111111
If we scan through the original array, we observe that the 2D pattern begins at the second row and the third column of the larger grid (the 8 in the second row and third column of the larger grid is the top-left corner of the pattern we are searching for).

So, a 2D pattern of P digits is said to be present in a larger grid G, if the latter contains a contiguous, rectangular 2D grid of digits matching with the pattern P, similar to the example shown above.

Input Format
The first line contains an integer, T, which is the number of test cases. T test cases follow, each having a structure as described below:
The first line contains two space-separated integers, R and C, indicating the number of rows and columns in the grid G, respectively.
This is followed by R lines, each with a string of C digits, which represent the grid G.
The following line contains two space-separated integers, r and c, indicating the number of rows and columns in the pattern grid P.
This is followed by r lines, each with a string of c digits, which represent the pattern P.

Constraints
1≤T≤5
1≤R,r,C,c≤1000
1≤r≤R
1≤c≤C
Test Case Generation
Each individual test case has been generated by first specifying the size (R and C) of the large 2D matrix, and then randomly generating the digits in it. A limited number of digits in the larger matrix may be changed by the problem setter (no more than 5% of the total number of digits in the matrix). So the larger 2D matrix is almost-random. The pattern matrix has been manually-curated by the problem setter.

Output Format
Display 'YES' or 'NO', depending on whether (or not) you find that the larger grid G contains the rectangular pattern P. The evaluation will be case sensitive.*/
